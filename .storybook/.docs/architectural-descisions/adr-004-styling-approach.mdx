{/* This file is automatically generated by the 'scripts/generate-docs.mjs' script. Do not edit it directly. */}

<Meta title="Architectural Decisions/Adr 004 Styling Approach" />

# ADR 004: Use SCSS Modules over Tailwind CSS for component styling

- **Date created**: 04/02/2025
- **Driver**: Alex Foxleigh (Foxy)

## Status

![accepted]

## Context

The project requires a styling solution that supports:

- Component-scoped styles to prevent CSS conflicts
- Design system integration with variables and mixins
- Maintainable and scalable styling architecture
- Developer productivity and ease of use
- Consistent theming across the application
- Support for complex styling patterns and animations

Alternative approaches considered:

- **Tailwind CSS**: Utility-first framework with rapid prototyping capabilities but limited design system integration
- **Styled Components**: CSS-in-JS with component-scoped styles but runtime performance overhead
- **Emotion**: CSS-in-JS library with good performance but complex theming patterns
- **Plain CSS**: Simple but prone to global conflicts and no preprocessing features
- **CSS Modules**: Scoped CSS without preprocessing features like variables and mixins

## Decision

Use SCSS Modules as the primary styling approach for the Jackanory design system.

## Consequences

### Positive

- **Scoped Styles**: Automatic CSS class name scoping prevents style conflicts without utility class pollution
- **Design System Integration**: SCSS variables, mixins, and functions enable sophisticated design token systems with mathematical operations and color manipulation
- **Semantic Class Names**: Component-specific class names that are self-documenting and meaningful in DevTools
- **Preprocessing Power**: Variables, nesting, mixins, and functions create maintainable, DRY stylesheets with complex logic
- **Performance**: Styles are extracted to CSS files with no runtime overhead, enabling aggressive caching and optimization
- **Debugging Experience**: Clear mapping between component styles and generated CSS classes with readable class names
- **Design Flexibility**: Can handle complex styling patterns, custom animations, and intricate responsive designs without framework constraints
- **Professional Workflow**: Aligns with traditional design-to-development handoff processes and designer expectations
- **Tool Support**: Excellent IDE support with syntax highlighting, autocomplete, and error detection

### Negative

- **Initial Setup Overhead**: Requires more upfront planning and architecture compared to utility-first approaches
- **Learning Curve**: Developers need to understand SCSS syntax, module system, and design system patterns
- **Maintenance Discipline**: Requires consistent adherence to styling conventions and patterns to prevent technical debt
- **Build Complexity**: Additional preprocessing step in the build pipeline with SCSS compilation
- **Potential Duplication**: Risk of style duplication across components without proper use of mixins and design tokens

### Mitigations

- Establish clear styling conventions and patterns in the design system
- Use SCSS mixins and functions to reduce code duplication
- Implement utility classes for common patterns while maintaining component-specific styles
- Provide comprehensive documentation and examples for styling patterns
- Use CSS purging tools to remove unused styles in production builds

## Implementation Notes

- Organize SCSS files with clear folder structure and naming conventions
- Create comprehensive theme system with variables for colors, typography, and spacing
- Use mixins for common patterns like responsive breakpoints and button styles
- Implement utility classes for frequently used styles
- Configure automatic imports of theme variables in Next.js configuration

## Why Tailwind CSS Was Not Chosen

While Tailwind CSS offers rapid prototyping capabilities, it was rejected for the following specific reasons:

### Design System Limitations

- **Utility Class Constraints**: Tailwind's predefined utility classes limit the ability to implement precise design specifications and custom design tokens
- **Design Token Integration**: Difficult to integrate complex design token systems with mathematical relationships and contextual variations
- **Brand Consistency**: Challenging to enforce strict brand guidelines when developers can mix and match utilities freely

### Developer Experience Issues

- **HTML Pollution**: Utility classes create verbose, hard-to-read HTML with dozens of classes per element
- **Debugging Complexity**: DevTools become cluttered with utility classes, making debugging and inspection difficult
- **Semantic Loss**: Class names like `bg-blue-500 p-4 rounded-lg` provide no semantic meaning about the component's purpose
- **Refactoring Challenges**: Changing design patterns requires updating utility classes across multiple components

### Maintenance and Scalability Concerns

- **Design Drift**: Easy for developers to create inconsistent designs by using different utility combinations for similar patterns
- **Custom CSS Escape Hatches**: Complex designs often require custom CSS anyway, defeating the utility-first purpose
- **Designer-Developer Handoff**: Designers working with traditional design tools struggle to communicate designs in utility class terms
- **Component Reusability**: Utility classes tied to specific implementations make component abstraction more difficult

### Performance Considerations

- **Bundle Size Reality**: While Tailwind can be smaller when purged, real-world applications often end up with large CSS bundles due to utility variety
- **Purging Complexity**: Proper CSS purging requires careful configuration and can break with dynamic class generation
- **Runtime Flexibility**: No ability to perform runtime calculations or dynamic theming without additional JavaScript

SCSS Modules addresses these concerns by providing a more structured, maintainable approach that aligns better with professional
design system development and long-term project sustainability.

[accepted]: https://img.shields.io/badge/Accepted-green?style=for-the-badge
[proposed]: https://img.shields.io/badge/Proposed-yellow?style=for-the-badge
[superceded]: https://img.shields.io/badge/Superceded-orange?style=for-the-badge
[rejected]: https://img.shields.io/badge/Rejected-red?style=for-the-badge
[deprecated]: https://img.shields.io/badge/Deprecated-grey?style=for-the-badge

