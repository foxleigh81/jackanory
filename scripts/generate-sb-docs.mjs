#!/usr/bin/env node

/**
 * This file automatically generates the MDX docs for Storybook from any
 * markdown files in the '/docs' directory or any file added to the
 * 'includes' array.
 */

import {
  statSync,
  readdirSync,
  readFileSync,
  writeFileSync,
  existsSync,
  cpSync,
  mkdirSync,
  rmSync,
  watch
} from 'fs';
import * as path from 'path';

// Replaces the old CJS __dirname with a variable mapped to the project root
const projectRoot = path.dirname(path.resolve('./package.json'));
const versionNumber = JSON.parse(
  readFileSync(path.resolve(projectRoot, 'package.json'), 'utf8')
).version;

// Includes and excludes should be relative to the root of the project
export const includes = ['docs'];
const excludes = ['.DS_Store'];

const sbRoot = path.resolve(projectRoot, '.storybook');
const output = path.resolve(sbRoot, '.docs');

// If the output directory doesn't exist, create it
if (!existsSync(output)) {
  mkdirSync(output, { recursive: true });
}

const rootReadMe = `
# What's this?

This folder is where the MDX versions of the files in the docs folder are stored.
It is automatically generated by the 'scripts/generate-docs.mjs' script and can safely
be ignored.
`;

const recurseDirectories = (file) => {
  if (excludes.includes(path.basename(file))) {
    return;
  }

  if (statSync(file).isDirectory()) {
    const dirs = readdirSync(file);
    return dirs.forEach((dir) => {
      // If the directory is the images folder, copy it to the output and return
      if (dir === 'images') {
        cpSync(
          path.join(file, dir),
          path.resolve(projectRoot, output, 'images'),
          {
            recursive: true
          }
        );
        return;
      }
      recurseDirectories(path.join(file, dir));
    });
  }

  // Get the file path from the repo root
  const filePath = path.resolve(projectRoot, file);
  const baseFileName = path.parse(filePath).name;
  console.log('Processing file: ', filePath);

  // Get the relative path from the docs directory
  const docsFolder = path.resolve(projectRoot, 'docs');
  const relativePath = path.relative(docsFolder, filePath);
  const dirName = path.dirname(relativePath);

  const outputDir = path.resolve(projectRoot, output, dirName);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  const fileContents = readFileSync(filePath, 'utf8');

  // Convert filename to sentence case for Meta title
  let metaTitle = baseFileName
    .replace(/-/g, ' ')
    .replace(/\b\w/g, (l) => l.toUpperCase())
    .replace(
      /\b[A-Z][a-z]+\b/g,
      (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    );

  // Special handling for index and ADRs
  if (baseFileName === 'index') {
    if (dirName === '.') {
      metaTitle = 'Introduction';
    } else {
      // Convert directory name to sentence case and use as prefix
      const dirTitle = dirName
        .replace(/-/g, ' ')
        .replace(/\b\w/g, (l) => l.toUpperCase())
        .replace(
          /\b[A-Z][a-z]+\b/g,
          (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        );
      metaTitle = `${dirTitle}/Introduction`;
    }
  } else if (baseFileName.startsWith('adr-')) {
    metaTitle = `Architectural Decisions/${metaTitle}`;
  } else if (dirName !== '.') {
    // For non-index files in subdirectories, prefix with directory name
    const dirTitle = dirName
      .replace(/-/g, ' ')
      .replace(/\b\w/g, (l) => l.toUpperCase())
      .replace(
        /\b[A-Z][a-z]+\b/g,
        (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      );
    metaTitle = `${dirTitle}/${metaTitle}`;
  }

  let convertedContent = `{/* This file is automatically generated by the 'scripts/generate-docs.mjs' script. Do not edit it directly. */}\n\n<Meta title="${metaTitle}" />\n\n`;

  const lines = fileContents.split('\n');
  let i = 0;
  let inCodeBlock = false;
  let codeBlockLanguage = '';
  let codeBlockContent = '';

  // Helper function to format code with proper indentation
  const formatCodeContent = (content) => {
    const lines = content.split('\n');
    return lines
      .map((line, index) => {
        if (index === 0 || index === lines.length - 1) {
          return line;
        }
        return '  ' + line;
      })
      .join('\n');
  };

  while (i < lines.length) {
    const line = lines[i];

    if (line === '' && convertedContent.endsWith('\n\n')) {
      i++;
      continue;
    }

    if (line.startsWith('#import')) {
      convertedContent = line.replace('#', '') + '\n\n' + convertedContent;
      i++;
      continue;
    }

    // Handle code blocks - convert to Storybook Source blocks
    if (line.startsWith('```')) {
      if (!inCodeBlock) {
        // Starting a code block
        inCodeBlock = true;
        codeBlockLanguage = line.substring(3).trim() || 'text';
        codeBlockContent = '';
        i++;
        continue;
      } else {
        // Ending a code block
        inCodeBlock = false;

        // Format the code content with proper indentation
        const formattedCode = formatCodeContent(codeBlockContent);

        // Generate Source block with proper escaping
        convertedContent += `<Source\n`;
        convertedContent += `  language="${codeBlockLanguage}"\n`;
        convertedContent += `  code={\`${formattedCode.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`}\n`;
        convertedContent += `/>\n\n`;

        codeBlockContent = '';
        codeBlockLanguage = '';
        i++;
        continue;
      }
    }

    // If we're inside a code block, collect the content
    if (inCodeBlock) {
      if (codeBlockContent !== '') {
        codeBlockContent += '\n';
      }
      codeBlockContent += line;
      i++;
      continue;
    }

    // Handle COLORPALETTE comments
    if (line.startsWith('<!-- COLORPALETTE:')) {
      const paletteMatch = line.match(/<!-- COLORPALETTE:(\w+)/);
      if (paletteMatch) {
        const paletteName = paletteMatch[1];
        let jsonData = '';
        i++; // Move to next line

        // Collect JSON data until we find the closing -->
        while (i < lines.length && !lines[i].includes('-->')) {
          jsonData += lines[i] + '\n';
          i++;
        }

        try {
          const colorData = JSON.parse(jsonData);
          convertedContent += `<ColorPalette>\n`;

          Object.entries(colorData).forEach(([name, color]) => {
            convertedContent += `  <ColorItem title="${name}" subtitle="${color}" colors={['${color}']} />\n`;
          });

          convertedContent += `</ColorPalette>\n\n`;
        } catch (error) {
          console.warn(
            `Failed to parse color palette data for ${paletteName}:`,
            error
          );
          convertedContent += line + '\n';
        }

        i++; // Skip the closing -->
        continue;
      }
    }

    // Handle TYPESET comments
    if (line.startsWith('<!-- TYPESET:')) {
      const typesetMatch = line.match(/<!-- TYPESET:(\w+)/);
      if (typesetMatch) {
        const typesetName = typesetMatch[1];
        let jsonData = '';
        i++; // Move to next line

        // Collect JSON data until we find the closing -->
        while (i < lines.length && !lines[i].includes('-->')) {
          jsonData += lines[i] + '\n';
          i++;
        }

        try {
          const typesetData = JSON.parse(jsonData);
          const { fontFamily, fontSizes, fontWeight } = typesetData;

          convertedContent += `<Typeset\n`;
          convertedContent += `  fontFamily="${fontFamily}"\n`;
          convertedContent += `  fontSizes={${JSON.stringify(fontSizes)}}\n`;
          convertedContent += `  fontWeight={${fontWeight}}\n`;
          convertedContent += `  sampleText="${typesetName === 'HEADINGS' ? 'Heading Sample Text' : 'The quick brown fox jumps over the lazy dog.'}"\n`;
          convertedContent += `/>\n\n`;
        } catch (error) {
          console.warn(
            `Failed to parse typeset data for ${typesetName}:`,
            error
          );
          convertedContent += line + '\n';
        }

        i++; // Skip the closing -->
        continue;
      }
    }

    // Add version number to the main heading in index.md
    if (
      baseFileName === 'index' &&
      line.startsWith('## Jackanory Documentation')
    ) {
      convertedContent += `${line} (version ${versionNumber})\n`;
      i++;
      continue;
    }

    const regex = /\[([\S ]+)\]\((\.\/[a-z0-9-]+\.md)\)/;
    if (regex.test(line)) {
      const [, , link] = line.match(regex);
      let convertedLink = link
        .replace(/\.\/(docs)?\/*/, '')
        .replace(/\//g, '-')
        .replace('.md', '--docs');
      if (link.includes('adr-')) {
        convertedLink = `/docs/documentation-architectural-decisions-${convertedLink}`;
      } else if (dirName === '.') {
        convertedLink = `/docs/documentation-${convertedLink}`;
      } else {
        convertedLink = `/docs/${dirName}-${convertedLink}`;
      }
      const newLine = line.replace(link, convertedLink);
      convertedContent += newLine + '\n';
    } else {
      convertedContent += line + '\n';
    }

    i++;
  }

  let fileName = '';
  if (baseFileName === 'README.md') {
    fileName = 'introduction.mdx';
  } else {
    fileName = baseFileName.replace('_', '-').toLowerCase() + '.mdx';
  }
  // Output the file to the output folder
  writeFileSync(path.resolve(outputDir, fileName), convertedContent, 'utf8');
};

const runGenerator = () => {
  // If the output directory exists, delete all files in it so we can start fresh
  if (existsSync(output)) {
    rmSync(output, { force: true, recursive: true });
  }
  mkdirSync(output, { recursive: true });
  // Create the root README file
  writeFileSync(
    path.resolve(projectRoot, output, 'README.md'),
    rootReadMe,
    'utf8'
  );

  // Process each directory listed in includes
  includes.map((d) => recurseDirectories(path.resolve(projectRoot, d)));
};

(function () {
  // Run the generator once to start with
  runGenerator();
  // If the script is called with '--watch' or '-w', watch for changes and re-run the generator
  if (process.argv.includes('--watch') || process.argv.includes('-w')) {
    console.log('Watching docs folder(s) for changes...');

    // Watch each directory in includes
    includes.forEach((dir) => {
      const watchPath = path.resolve(projectRoot, dir);
      watch(watchPath, { recursive: true }, (eventType, filename) => {
        if (filename) {
          console.log(`${eventType}: ${filename}`);
          runGenerator();
        }
      });
    });
  }
})();
